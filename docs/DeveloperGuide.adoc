= Incident Management System - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]
:repoURL: https://github.com/AY1920S1-CS2103-T11-1/main
:websiteURL: https://ay1920s1-cs2103-t11-1.github.io

By: `Team CS2103-T11-1`      Since: `October 2019`      Licence: `MIT`

== Setting up

Refer to the guide <<SettingUp#, here>>.

== Design

[[Design-Architecture]]
=== Architecture

.Architecture Diagram
image::ArchitectureDiagram.png[]

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of each component.

[TIP]
The `.puml` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder.
Refer to the <<UsingPlantUml#, Using PlantUML guide>> to learn how to create and edit diagrams.

`Main` has two classes called link:{repoURL}/src/main/java/seedu/address/Main.java[`Main`] and link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

<<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple other components.
The following class plays an important role at the architecture level:

* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components.

* <<Design-Ui,*`UI`*>>: The UI of the App.
* <<Design-Logic,*`Logic`*>>: The command executor.
* <<Design-Model,*`Model`*>>: Holds the data of the App in-memory.
* <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see the class diagram given below) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

.Class Diagram of the Logic Component
image::LogicClassDiagram.png[]

[discrete]
==== How the architecture components interact with each other

The _Sequence Diagram_ below shows how the components interact with each other for the scenario where the user issues the command `delete 1`.

.Component interactions for `delete 1` command
image::ArchitectureSequenceDiagram.png[]

The sections below give more details of each component.

[[Design-Ui]]
=== UI component

.Structure of the UI Component
image::UiClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `PersonListPanel`, `StatusBarFooter` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Listens for changes to `Model` data so that the UI can be updated with the modified data.

[[Design-Logic]]
=== Logic component

[[fig-LogicClassDiagram]]
.Structure of the Logic Component
image::LogicClassDiagram.png[]

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `IncidentManagerParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a person).
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.
.  In addition, the `CommandResult` object can also instruct the `Ui` to perform certain actions, such as displaying help to the user.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete 1")` API call.

.Interactions Inside the Logic Component for the `delete 1` Command
image::DeleteSequenceDiagram.png[]

NOTE: The lifeline for `DeleteCommandParser` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.

[[Design-Model]]
=== Model component

.Structure of the Model Component
image::ModelClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores the Incident Manager data.
* exposes an unmodifiable `ObservableList<Person>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

[NOTE]
As a more OOP model, we can store a `Tag` list in `IncidentManager`, which `Person` can reference. This would allow `IncidentManager` to only require one `Tag` object per unique `Tag`, instead of each `Person` needing their own `Tag` object. An example of how such a model may look like is given below. +
 +
image:BetterModelClassDiagram.png[]

[[Design-Person]]
==== Person Model component

*API* : link:{repoURL}/src/main/java/seedu/address/model/Person.java[`Person.java`]

The `Person`,

* represents a user account on the incident manager.
* Contains the account `Username`, `Password`, `Name`, `Phone`, `Email`

[[Design-Incident]]
==== Incident component

*API* : link:{repoURL}/src/main/java/seedu/address/model/Incident.java[`Incident.java`]

The `Incident`,

image::IncidentClassDiagram.png[]

* represents an incident report in the incident manager.
* contains the attributes `CallerNumber`, `Description`, `IncidentDateTime` and IncidentId`.
* Also contains a `Person` object representing the 'Operator' who filed the incident, a `District` which represents the location of the incident, and a `Vehicle` representing the vehicle dispatched to investigate this incident.
* Has three states encapsulated by a `Status` enum - `INCOMPLETE_DRAFT` (report not completely filled and not submitted), `COMPLETE_DRAFT` (report completely filled but not submitted), and `SUBMITTED_REPORT` (report completely filled and submitted).

[[Design-Vehicle]]
==== Incident component

*API* : link:{repoURL}/src/main/java/seedu/address/model/Vehicle.java[`Vehicle.java`]

The `Vehicle`,

* represents a vehicle that can be dispatched to incident sites.
* Contains the attributes `VehicleNumber`, `VehicleType`, `district` and `availability`.

[[Design-Storage]]
=== Storage component

.Structure of the Storage Component
image::StorageClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the Incident Manager data in json format and read it back.

[[Design-Commons]]
=== Common classes

Classes used by multiple components are in the `seedu.incidentManager.commons` package.

== Implementation

This section describes some noteworthy details on how certain features are implemented.

// tag::accessControl[]
=== Access Control feature
==== Implementation

The access control feature is centered around three core concepts:

1. Command Restrictions: Restriction of access to commands until after identity is verified
2. Identity Verification: Verification of identity via unique credentials and a confidential key
3. Account Management Restrictions: Access level restrictions for commands affecting other accounts

===== Command Restrictions

Prior to login, the user is only granted access to the `Login`, `Register`, `Help`, and `Exit` commands. This is achieved via a guard statement in the `LogicManager` checking whether the user is logged in or the command created is an approved command that doesn't require login.

[NOTE]
The guard statement throws a command exception and informs the user of the available commands prior to login.

Activity Diagram for illustration:

image::AccessActivityDiagram.png[]

===== Identity Verification

Users are required to login via the `Login` command with a `Username` and `Password`. See user guide for more details on the command syntax for `Login`. Users are also allowed to `Logout` and thus end their `Session`.

[NOTE]
Session details are displayed on the status bar in the GUI to reflect whether a user is logged in, and the username as well as time logged in if a user is logged in.

Class Diagram for illustration:

image::SessionClassDiagram.png[]

Uniqueness of a username is ensured by preventing duplicates during the account creation [`RegisterCommand`] and account update [`UpdateCommand`] processes. The respective commands will check the list of accounts in the model and throw an exception if a duplicate is found.

===== Account Management Restrictions

To prevent abuse (e.g. adding a dummy account and editing/deleting other accounts), all new accounts are differentiated from `Admin` accounts. This restriction based on access level is implemented via account `Tags`:

* Only a `Person` with an admin `Tag` can access account management features. Such a person will henceforth be referred to as an Admin.
* Users who are not admins are not allowed to add tags (via both AddCommand and UpdateCommand).
* Only Admins are allowed to edit or add tags (via both AddCommand and UpdateCommand).

[NOTE]
Non-admins can still edit their own account details via the `UpdateCommand`. Refer to user guide for more info.

Additional access restrictions:

* Only admins can update an account that is not their own.
* Only admins can access the delete command.
* Admins cannot delete their own account.
* Admins cannot 'downgrade' themselves by removing their own admin tag.

The checks described above all function in the command execution stage. The `RegisterCommand`, `UpdateCommand`, and `DeleteCommand` retrieves the logged in `Person` from the `Model` via utilisation of the `Session` object.

Sequence Diagram for illustration:

image::AccessSequenceDiagram.png[]

NOTE: The lifeline for DeleteCommand should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of the diagram.

==== Design Considerations

===== Aspect: How Command Restrictions are Managed

* **Current Choice:** Guard statement in LogicManager prior to Command Execution.
** Pros: Single control point, easy to maintain and debug.
** Cons: Command still gets instantiated, memory allocated to command creation.
* **Alternative:** Guard statement in IncidentManagerParser
** Pros: Early catching of restriction, command doesn't get instantiated unnecessarily.
** Cons: Need to expose model to parser, increasing coupling.

===== Aspect: How Identity Verification is Managed

* **Current Choice:** Unique username and password.
** Pros: Easy to implement.
** Cons: Sufficiently advanced users can access the data file directly to retrieve user passwords.
* **Alternative:** Physical security USB dongle.
** Pros: Secure individually identifiable token.
** Cons: Prone to loss and potential duplication.

===== Aspect: How Account Management Restrictions are Managed

* **Current Choice:** Utilisation of Account Tags
** Pros: Easy to implement.
** Cons: Users cannot add tags to themselves.
* **Alternative:** Addition of an Admin account attribute.
** Pros: Distinct object class, improves cohesiveness.
** Cons: Hard to implement.

==== Known Issues

A sufficiently advanced user can access the data file directly to manipulate account details. Data file encryption will resolve this issue, but has yet to be implemented.
// end::accessControl[]

// tag::accountManagement[]
=== Account Management feature
==== Implementation

The account management feature functions as a suite of commands available to the user. The commands available as part of this suite:

* Register Command - Creates a new user account.
* Update Command - Edits a user account. Not including an index updates your own account.
* Delete Command - Deletes a a user account. Not allowed to delete your own account.
* List Persons Command - Lists all user accounts or those whose tags match the user input.
* Find Persons Command - Searches for user accounts based on matching name or username keywords.
* Swap Command - Swaps GUI interface between account management and incident management.

[NOTE]
Users are restricted from accessing commands affecting objects not on display. They need to invoke `Swap` to access the different command suites.

Only `Admin` accounts can access the full suite of account management features. See access control feature for more information. Non-Admins only have access to `Register`, `List`, `Find`, and `Swap` commands, as well as `Update` for their own account.

In the code base, Persons represent user accounts. See person model for more information.

==== Design Considerations
===== Aspect: How Update executes

* **Current Choice:** No index indicates own account update
** Pros: Improves user experience, user does not need to look for their own index.
** Cons: Susceptible to user error.
* **Alternative:** Select index of own account for update
** Pros: Easy to implement.
** Cons: Decreases user experience, user will first need to find their own index.

===== Aspect: How Tag searching executes

* **Current Choice:** Adding keywords after the list command performs a search
** Pros: Does not require argument prefixes, improves user experience.
** Cons: Decreases system cohesiveness as searching is performed in two separate commands.
* **Alternative:** Utilising find command to search for tags
** Pros: Centralise all account search operations in one command, improves system cohesiveness.
** Cons: Requires the addition of argument prefixes, decreases user experience.
// end::accountManagement[]

// tag::incidentdraftcreation[]
=== Incident Draft Creation feature
==== Proposed Implementation

The incident draft creation mechanism is facilitated by the New Command. It creates a new draft incident report based on district of incident, optional automatic vehicle dispatchment.

With automatic vehicle dispatchment:

image::NewDraftSequenceDiagramAuto.png[]

With manual vehicle dispatchment:

image::NewDraftSequenceDiagramManual.png[]

==== Design Considerations

===== Aspect: How incident draft creation executes

* **Alternative 1:** Auto assignment of vehicles
** Pros: Reduces number of steps of execution.
** Cons: User does not get to choose vehicle to dispatch.
* **Alternative 2:** Manual assignment of vehicles
** Pros: User is able to choose vehicle to dispatch.
** Cons: More number of steps.
// end::incidentdraftcreation[]

// tag::incidentfillandsubmit[]
=== Incident Filling and Submission feature
==== Implementation
The incident filling and submission subroutines are facilitated by the `fill` and `submit` commands respectively.
In the IMS, each incident can have one of three statuses - `INCOMPLETE_DRAFT`, `COMPLETE_DRAFT`, and `SUBMITTED REPORT`.
These three statuses are maintained by an `enum` in `Incident`. Executing the `fill` command changes the status of
drafts (complete or incomplete) into `COMPLETE_DRAFT` while the `submit` command changes the status of only `COMPLETE_DRAFTS` to `SUBMITTED_REPORT`.

===== Overview of `Fill` and `Submit`

Each command works in two modes:

1. Without parameters: +
In this mode, the command - `fill` or `submit` - lists the incidents that are ready for Filling (i.e. only all complete and incomplete drafts) or Submitting (i.e. only all complete drafts).
2. With parameters:
In this mode, the command - `fill` or `submit` - actually fills (i.e. makes incident status `COMPLETE_DRAFT`) or submits (i.e. changes incident status from `COMPLETE_DRAFT` to `SUBMITTED_REPORT`) the specified incident.

The implementation of these two modes is discussed below. As both `fill` and `submit` are rather similar in their implementation, a detailed discussion of only the `fill` command is given below.

===== No parameter mode (listing incidents)

This mode leverages the ability of the `ListIncidentsCommand` to list incidents by different predicates.
When the `IncidentManagerParser` parses a `fill` command without parameters, it returns a new `ListIncidentsCommand`
with predicate `Incident::isDraft`. This `ListIncidentsCommand` is then executed as per usual.

For the `submit` command, the predicate `Incident::isCompleteDraft` is used instead.

image::FillCommandNoParamsSequenceDiagram.png[]

===== Parameter mode (modifying incidents)
* For the `fill` command with parameters, the `FillCommandParser` will be invoked to parse the fields `targetIndex`, `callerNumber`, and `description` and return a `FillCommand` containing these non-null fields.
* The `execute()` method in `FillCommand` will then retrieve the specified incident if there are drafts to be filled and if the index is valid.
* Two helper methods - `processReportFilling` and `fillReport` - will complete the filling process. `fillReport` returns a new `Incident` which is a copy of the incident report to be filled, but with the specified caller and description details and a `COMPLETE_DRAFT` status.
* The old incident report will be removed from the system and be replaced with the new updated incident report.
* The new incident report is placed at the front of the incident list for easy access.

image::FillCommandWithParamsSequenceDiagram.png[]
.In this sequence diagram, the helper methods within `FillCommand` are omitted for clarity.

The `SubmitCommand` functions similarly, with one crucial difference. As no Incident fields are to be updated, the specified incident is simply retrieved, and its fields are copied into a new `Incident` object with a `SUBMITTED_REPORT` status.

==== Design Considerations

===== Aspect: How incident `fill` and `submit` commands execute in no parameter mode

* **Current choice:** Use `ListIncidents` command with appropriate predicate to fulfill `fill` and `submit` functionalities in no-parameter mode.
** Pros: +
1. Intuitive and convenient to use. If user needs easy access to reports that can be filled or submitted, they do not need to remember a new command keyword. +
2. Requires lesser code. Abstraction of the filtered listing subroutine reduces the amount of redundant code. +
** Cons: +
1. Might be potentially confusing to user as `FillCommand` is performing a function of listing that is extraneous to the function of filling.
2. This mode might be redundant **if** the user follows a strict incident management workflow where any newly generated incident is promptly filled and submitted without it remaining in the system as a draft.
* **Alternative 1:** Extend `FillCommand` to create two child classes `FillCommandNoParams` and `FillCommandWithParams`. +
** Pros: +
1. Better use of the OOP principle of inheritance. +
2. Reduce coupling between `ListIncidentsCommand` and `FillCommand`.
** Con: +
1. Increases amount of code and hence marginally reduces app performance as one additional new class needs to be created.
2. Misleading use of abstraction as the `FillCommandNoParams` is technically not performing the function of filling but that of listing.
* **Alternative 2:** Separate the 'listing' and the 'filling' aspect by using separate command words.
** Pro: +
1. Most appropriate use of abstraction and single responsibility principle, which are crucial OOP concepts.
** Con: +
1. User needs to either remember an additional command word or type a longer `list-i` command by specifying the filter predicate, which reduces user convenience.

===== Aspect: How incident `fill` and `submit` commands execute in parameter mode

* **Current choice:** Both `callerNumber` and `description` fields need to be specified when filling specified incident report. The other incident report fields are auto-filled and can only be changed by using the `edit` command once the incident report has been submitted.
** Pros: +
1. Improved accountability. Prevents a user from changing the most important fields of the incident report, such as `incidentId`, `incidentDateTime`, and `vehicle`, without first committing the report into the system. +
2. More convenient for the user as they only have to specify 2 report fields instead of 6 or 7.
** Cons: +
1. User is unable to fill `callerNumber` independently of `description` unless they first submit the incident report and then use the `edit` command.
2. If an incident report has a very long description, then this way of filling the report can be troublesome.
* **Alternative 1:** Combine `fill` and `submit` functions i.e. filling a report completely will automatically submit it.
** Pros: +
1. Easier to implement as Incident reports have two statuses - DRAFT or SUBMITTED - instead of three.
2. More convenient as this results in one less step in the user's workflow and one less command word for the user to remember.
** Con: +
1. Less adaptable and modular. If new fields are added to the incident report, then the user might want to enter / replace those fields by executing repeated fill commands in parameter mode without committing the report into the system and possibly alerting their supervisors and/or relevant agencies with incomplete / likely to change information.
* **Alternative 2:** Allow `fill` command to fill variable number of fields.
** Pro: +
1. Satisfies the cons of the two approaches above as it is versatile enough to allow the user to independently fill different incident report fields as well as adaptable enough to accommodate extra fields.
** Con: +
1. Harder to implement as we would need to make elaborate and thorough methods to parse the variable arguments.

==== Known Issues

A user cannot independently fill the various incident report fields unless they first submit the incident report.

==== Activity diagram summarising Incident creation, filling, and submission features

image::IncidentReportingActivityDiagram.png[]

In this activity diagram, the catch-all term 'report' is used to encompass the acts of creating, filling, and submitting incident reports.

// end::incidentfillandsubmit[]

// tag::incidentsearch[]
=== Incident Search feature
==== Implementation

The incident search mechanism features a set of different types of searches that a user could utilise. Further documentation on the commands available in this set can be found within the link:{websiteURL}/main/UserGuide.html. The types of searches are as listed:

* Unfiltered - Displays all incidents in `Model`
* ID - Displays all incidents with exact matches in `IncidentId incidentId` in `Incident incident`
* Description - Displays all incidents with keyword(s) contained within the `Description description` in `Incident incident`
* Operator - Displays all incidents with keyword(s) contained within the name of the `Person operator` in `Incident incident`

The incident search mechanism is facilitated by `ModelManager`, which implements abstract class `Model`. It contains a `FilteredList<Incidents> filteredIncidents`, which internally stores the list of displayed incidents in the GUI. Additionally, it implements the following key method:
* `updateFilteredIncidentsList(Predicate<Incident> predicate)` - Updates the stored filtered incidents list with the new predicate

There are two possible commands within this set of searches. Firstly, we will consider when the user calls the command `incidents` in the application.

The following sequence diagram shows how the `incidents` command works:

image::ListIncidentsSequenceDiagram.png[]

As indicated in the diagram, the `LogicManager` instantiates a `ListIncidentsCommand` upon running command `execute(incidents)`. It then calls `ListIncidentsCommand#execute()`, which runs `Model#updateFilteredIncidentList` with the predicate `PREDICATE_SHOW_ALL_INCIDENTS`. This `Predicate<Incident>` always evaluates to true. This `Predicate<Incident>` is passed to `FilteredList<Incident> filteredList`, as a parameter to run the method `setPredicate()`. This updates the list of visible incidents. `CommandResult commandResult` is also returned to the `LogicManager` to log the success/failure of the method.

Next, we will look at an example in which the user calls `search` to look for incidents written by an operator whose name contains `Alex`.

The execution of this method is a little more complex.

The following sequence diagram shows how the `search` command identifies the keyword and flag, and returns related incidents:

image::SearchIncidentsSequenceDiagram.png[]

The key difference is the utility of the `SearchIncidentsCommandParser` to parse the keyword after tag `op\` in the command. It creates a `NameKeywordsPredicate` using the String "Alex", which is returned to be used in constructing a new instance of `SearchIncidentsCommand`, stored as a `Predicate<Incident> predicate`. From there, the process is similar, in that `SearchIncidentsCommand#execute()` is run, causing the Model to run `Model#updateFilteredIncidentList(predicate)` using the predicate stored in `SearchIncidentsCommand`. Upon updating the list similar to the `incidents` listing command above, `SearchIncidentsCommand` also calls `Model#getFilteredIncidentList()` to return `ObservableList<Incident>`. It obtains the size of this list, and returns it in `CommandResult commandResult`.

==== Design Considerations

===== Aspect: How incident search keyword is inputted

* **Alternative 1 (current choice):** Parse user input after flag (eg. `op\` or `desc\`)
** Pros: Easy to implement.
** Cons: Have to parse keyword from command and flag, user has to follow style of flag for successful search.
* **Alternative 2:** Prompt user for search input
** Pros: Separates command from keyword for ease of reading and parsing.
** Cons: Difficult to implement multi-command execution.

===== Aspect: How listing all incidents is called

* **Alternative 1 (current choice):** Utilise separate command `incidents`
** Pros: Intuitive to use.
** Cons: Similar code under different command.
* **Alternative 2:** Utilise `search` command (eg. `search unfiltered`)
** Pros: Less overlap in code.
** Cons: Unintuitive to the user as no search is being made, even more keywords to remember.

===== Aspect: How predicate is added to `SearchIncidentsCommand`

* **Alternative 1 (current choice):** `SearchIncidentsCommandParser` class calls `Model` to create a new Predicate based on search string.
** Pros: Abstracts the creation and management of predicates to the `Model`.
** Cons: Requires greater level of coupling between classes.
* **Alternative 2:** `SearchIncidentsCommand` or `SearchIncidentsCommandParser` directly create Predicate based on search string.
** Pros: Less dependencies within the parser class.
** Cons: Breaks abstraction flow.
// end::incidentsearch[]

// tag::incidentedit[]
=== Incident Edit feature
==== Proposed Implementation

The incident edit mechanism is facilitated by `EditCommand` class. Validity of user input is checked when `execute()` is called and an exception is thrown if invalid.

An exception will be thrown under these 2 conditions:
* `index.getZeroBased() >= listOfIncidents.size()`
* `!incidentToEdit.equals(editedIncident) && model.hasIncident(editedIncident)`

Below is an activity diagram to illustrate the process that the user may go through

image::EditCommandActivity.png[]

To prevent direct access and modification to the attributes in an incident object, a new incident object is created
using `EditIncident` each time the command is executed and then replaced at the specified index in a
`List<Incident>` that is facilitated by `FilteredIncidentList` class. This is all done in the execution stage.

Below is a sequence diagram to illustrate how the command executes:

image::EditCommandSequence.png[]

==== Design Considerations

===== Aspect: How incident edit executes

* **Alternative 1 (current choice):** Create a new incident object and replace the old copy in the list
** Pros: able to control access to attributes in incident objects
** Cons: more tedious implementation and more objects created
* **Alternative 2:** Directly access the attributes of the incident and change it
** Pros: less objects created, do not need to worry much about `IncidentId` of instance.
** Cons: More prone to errors since attributes can be directly access and changed outside the class.
// end::incidentedit[]

// tag::vehiclesearch[]
=== Vehicle Search feature
==== Implementation

The vehicle search mechanism features a set of different types of searches that a user could utilise. Further documentation on the commands available in this set can be found within the link:{websiteURL}/main/UserGuide.html. The types of searches are as listed:

* Unfiltered - Displays all vehicles in `Model`
* District - Displays all vehicles with exact matches in `District district` in `Vehicle vehicle`
* Vehicle Number - Displays all vehicles with exact matches in `VehicleNumber vehicleNumber` in `Vehicle vehicle`
* Vehicle Type - Displays all vehicles with exact matches in `VehicleType vehicleType` in `Vehicle vehicle`

The vehicle search mechanism is facilitated by `ModelManager`, which implements abstract class `Model`. It contains a `FilteredList<Vehicle> filteredVehicles`, which internally stores the list of displayed vehicles in the GUI. Additionally, it implements the following key method:

* `updateFilteredVehiclesList(Predicate<Vehicle> predicate)` - Updates the stored filtered vehicle list with the new predicate

==== Design Considerations

===== Aspect: How vehicle search keyword is inputted

* **Current choice:** Parse user input after flag (eg. `ds\` or `vnum\`)
** Pros:
*** Easy to implement.
*** Reduce number of steps of input, more efficient.
** Cons:
*** Have to parse keyword from command and flag, user has to follow style of flag for successful search.
* **Alternative 2:** Prompt user for search input
** Pros: Separates command from keyword for ease of reading and parsing.
** Cons:
*** Difficult to implement multi-command execution.
*** Requires multiple steps of input, slower and less efficient.

===== Aspect: How listing all incidents is called

* **Current choice:** Utilise separate command `vehicles`
** Pros: Easy to implement.
** Cons: Might not be very intuitive; user might prefer action words like `list vehicles"
* **Alternative 2:** Utilise `list` command (eg. `list vehicles`)
** Pros: Intuitive and clear.
** Cons: More keywords to parse.

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g user prefs file location, logging level) through the configuration file (default: `config.json`).

== Documentation

Refer to the guide <<Documentation#, here>>.

== Testing

Refer to the guide <<Testing#, here>>.

== Dev Ops

Refer to the guide <<DevOps#, here>>.

[appendix]
== Product Scope

*Target user profile*: Emergency Services Call Operator

* needs to quickly dispatch emergency vehicles
* has a need to manage a significant number of incidents
* prefer desktop apps over other types
* can type fast, prefers typing over mouse input
* is reasonably comfortable using CLI apps

*Value proposition*: manage incidents and vehicle dispatch faster than a typical mouse/GUI driven app

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...

|`* * *` |new user |see usage instructions |refer to instructions when I forget how to use the App

|`* * *` |operator |log into the system with a password |secure the system against unauthorised access

|`* * *` |operator |log into the system with a unique identifier |hold accountable others who use the system

|`* * *` |new user |create an account |log into the system to manage incidents

|`* * *` |operator |open the app |I can dispatch personnel and record an incident

|`* * *` |operator |view available vehicles |I can dispatch vehicles

|`* * *` |confused operator	|automatically prevent sending of non available vehicles |I won't be allowed to send occupied vehicles

|`* * *` |operator |to select a vehicle	|it would be dispatched

|`* * *` |operator |to contact the dispatched vehicle and confirm it has been selected |it would be dispatched

|`* * *` |operator |an ID to be generated for my summaries |my reports can be tagged for easy search

|`* * *` |operator |to have prompts for fields |I know the information required

|`* * *` |careless operator	|edit the report |I won't have to retype everything

|`* * *` |operator on shift	|to save the case for future retrieval |So that others can reference it locally

|`* *` |operator handling many cases |to quickly find relevant parties |I can submit the incident log

|`* *` |regular operator |to view the phone number |I can contact the caller whenever necessary

|`* *` |regular operator |to view the address |I can dispatch personnel based on proximity to address

|`* *` |operator who likes visual cues |to view the vehicles on patrol on a map |I have a visual on who to dispatch

|`* *` |As an operator |to view the available vehicles in descending order of proximity to site |the vehicle can reach the incident site asap

|`* *` |As an overwhelmed operator |to filter the available vehicles |I won't get confused over which vehicle to send

|`* *` |As a tired operator |warning prompt when I select the least optimal available vehicle |I minimise fatigue errors

|`* *` |As a busy operator |automatic spell and grammar check |so that I can type fast without worry

|`* *` |As an operator |keyboard shortcuts |I can type while I talk

|`* *` |As an operator working under supervisors |to alert the relevant parties |So that they can act on it

|`*` |advanced operator |to auto-transcribe the call |I can store the call transcript for record-keeping purposes

|`*` |operator |automatic triangulation of the call location |I can dispatch a vehicle even if the caller does not know his/her address

|`*` |as an anxious operator |nearby vehicles to be notified of the incident even though they're not dispatched |In case backup is needed

|`*` |As an operator that has to take many calls |to select from drop down lists for certain fields  |so that I can fill in the summary report fast

|=======================================================================

[appendix]
== Use Cases

(For all use cases below, the *System* is the `IMS` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
=== Use case: User Login

*MSS*

1.  User inputs username and password
2.  IMS checks username & password
3.  IMS provides user with access
+
Use case ends.

*Extensions*

[none]
* 2a. The username is not found or password is incorrect.
+
[none]
** 2a1. IMS shows a generic error message to deter malicious intent.
Use case ends.

[discrete]
=== Use case: New incident

*MSS*

1.  User requests to create a new incident
2.  IMS prompts for confirmation of vehicle assignment
3.  User accepts auto assigned vehicle for dispatch
4.  IMS creates a new incident with autofill details
5.  IMS prompts for completion of incident report
6.  User fills in necessary details
7.  User submits incident report
+
Use case ends.

*Extensions*

[none]
* 3a. User opts for manual assignment.
+
[none]
** 3a1. IMS displays list of all available vehicles.
** 3a2. User selects index of vehicle to dispatch.
+
Use case resumes at step 4.

[none]
* 6a. User opts to complete report later.
+
[none]
** 6a1. IMS stores incident as a draft.
+
Use case ends.

[discrete]
=== Use case: Edit Incident

*MSS*

1.  User searches for an incident
2.  IMS retrieves the incident
3.  User edits the incident details
4.  IMS saves the edited incident report
+
Use case ends.

*Extensions*

[none]
* 2a. The incident is not found.
+
[none]
** 2a1. IMS shows an error message.
+
Use case ends.

[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `11` or above installed.
.  Should be able to hold up to 1000 incidents without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.
.  Performance first for vehicle dispatch upon new incident creation.
.  Interface should prioritise user experience since operators function in a high stress environment.

[appendix]
== Glossary

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[[IMS]] IMS::
Incident Management System

[appendix]
== Product Survey

*Product Name*

Author: ...

Pros:

* ...
* ...

Cons:

* ...
* ...

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with a set of sample contacts. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

_{ more test cases ... }_

=== Deleting a person

. Deleting a person while all persons are listed

.. Prerequisites: List all persons using the `list` command. Multiple persons in the list.
.. Test case: `delete 1` +
   Expected: First contact is deleted from the list. Details of the deleted contact shown in the status message. Timestamp in the status bar is updated.
.. Test case: `delete 0` +
   Expected: No person is deleted. Error details shown in the status message. Status bar remains the same.
.. Other incorrect delete commands to try: `delete`, `delete x` (where x is larger than the list size) _{give more}_ +
   Expected: Similar to previous.

_{ more test cases ... }_

=== Saving data

. Dealing with missing/corrupted data files

.. _{explain how to simulate a missing/corrupted file and the expected behavior}_

_{ more test cases ... }_
